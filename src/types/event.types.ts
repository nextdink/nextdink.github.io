// Event visibility and join rules
export type EventVisibility = 'public' | 'code' | 'private';
export type EventJoinType = 'open' | 'invite_only';
export type EventStatus = 'active' | 'canceled' | 'completed';

// Team member types
export type TeamMemberType = 'user' | 'guest' | 'open';

/**
 * TeamMember represents a single slot in a team registration.
 * 
 * - type='user': A registered user (the team captain)
 * - type='guest': A name entered by the captain (can be claimed by any user)
 * - type='open': "Looking for partner" slot (can be claimed by any user)
 */
export interface TeamMember {
  type: TeamMemberType;
  userId?: string;          // Only for 'user' type
  displayName?: string;     // For 'user' (from profile) or 'guest' (entered name)
  photoUrl?: string | null; // Only for 'user' type
}

/**
 * TeamRegistration represents a team's registration for an event.
 * Teams are ordered by registration time (FIFO) for waitlist calculation.
 */
export interface TeamRegistration {
  id: string;                    // Auto-generated UUID
  createdBy: string;             // User ID of team captain
  createdAt: Date;               // For ordering (FIFO)
  members: TeamMember[];         // Length must equal event.teamSize
}

/**
 * EventLocation contains structured location data for an event.
 */
export interface EventLocation {
  venueName: string;
  formattedAddress: string;
  latitude: number;
  longitude: number;
  placeId?: string;
}

/**
 * Event represents a pickleball game/session.
 * 
 * Capacity is calculated as: teamSize Ã— maxTeams
 * Joined teams = first N registrations where N = maxTeams
 * Waitlisted teams = remaining registrations after maxTeams
 */
export interface Event {
  id: string;
  name: string;
  description?: string;
  date: Date;
  endTime: Date;
  
  // Team-based capacity
  teamSize: number;         // 1-4 players per team, default 1
  maxTeams: number;         // Maximum number of teams allowed
  
  // Location
  venueName: string;
  formattedAddress: string;
  latitude: number;
  longitude: number;
  placeId?: string;
  
  // Visibility & Join Rules
  visibility: EventVisibility;
  joinType: EventJoinType;
  eventCode: string;        // Always set, unique across active events
  
  // Status
  status: EventStatus;
  
  // Roles
  ownerId: string;
  adminIds: string[];
  
  // Team registrations (ordered array)
  // Joined teams = registrations.slice(0, maxTeams)
  // Waitlisted teams = registrations.slice(maxTeams)
  registrations: TeamRegistration[];
  
  // Event-level invitations (for private/invite-only events)
  invitedUserIds: string[];
  
  // System
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Data required to create a new event.
 * eventCode is auto-generated by the service.
 */
export interface CreateEventData {
  name: string;
  description?: string;
  date: Date;
  endTime: Date;
  teamSize: number;
  maxTeams: number;
  venueName: string;
  formattedAddress: string;
  latitude: number;
  longitude: number;
  placeId?: string;
  visibility: EventVisibility;
  joinType: EventJoinType;
}

/**
 * Data for updating an existing event.
 * All fields are optional.
 */
export interface UpdateEventData {
  name?: string;
  description?: string;
  date?: Date;
  endTime?: Date;
  teamSize?: number;
  maxTeams?: number;
  venueName?: string;
  formattedAddress?: string;
  latitude?: number;
  longitude?: number;
  placeId?: string;
  visibility?: EventVisibility;
  joinType?: EventJoinType;
}

/**
 * Data for registering a new team.
 */
export interface RegisterTeamData {
  members: TeamMember[];
}

// ============================================
// Utility functions for capacity calculations
// ============================================

/**
 * Calculate total capacity for an event.
 */
export function getTotalCapacity(event: Event): number {
  return event.teamSize * event.maxTeams;
}

/**
 * Get joined teams (within capacity).
 */
export function getJoinedTeams(event: Event): TeamRegistration[] {
  return event.registrations.slice(0, event.maxTeams);
}

/**
 * Get waitlisted teams (beyond capacity).
 */
export function getWaitlistedTeams(event: Event): TeamRegistration[] {
  return event.registrations.slice(event.maxTeams);
}

/**
 * Count filled player spots (registered users only) in joined teams.
 */
export function getFilledSpotsCount(event: Event): number {
  const joinedTeams = getJoinedTeams(event);
  return joinedTeams.reduce(
    (sum, team) => sum + team.members.filter(m => m.type === 'user').length,
    0
  );
}

/**
 * Count claimable spots (open + guest) in joined teams.
 */
export function getClaimableSpotsCount(event: Event): number {
  const joinedTeams = getJoinedTeams(event);
  return joinedTeams.reduce(
    (sum, team) => sum + team.members.filter(m => m.type === 'open' || m.type === 'guest').length,
    0
  );
}

/**
 * Check if a user is already registered in any team for an event.
 */
export function isUserInEvent(event: Event, userId: string): boolean {
  return event.registrations.some(team =>
    team.members.some(member => member.type === 'user' && member.userId === userId)
  );
}

/**
 * Find the team registration a user belongs to.
 */
export function getUserTeam(event: Event, userId: string): TeamRegistration | undefined {
  return event.registrations.find(team =>
    team.members.some(member => member.type === 'user' && member.userId === userId)
  );
}

/**
 * Check if a user is the captain of a team.
 */
export function isTeamCaptain(team: TeamRegistration, userId: string): boolean {
  return team.createdBy === userId;
}

/**
 * Get the user's status in an event (joined, waitlisted, or not registered).
 */
export function getUserEventStatus(
  event: Event, 
  userId: string
): 'joined' | 'waitlisted' | 'invited' | 'not_registered' {
  // Check if invited
  if (event.invitedUserIds.includes(userId)) {
    // Also check if they've joined after being invited
    if (isUserInEvent(event, userId)) {
      const userTeam = getUserTeam(event, userId);
      if (userTeam) {
        const teamIndex = event.registrations.indexOf(userTeam);
        return teamIndex < event.maxTeams ? 'joined' : 'waitlisted';
      }
    }
    return 'invited';
  }
  
  // Check if in a team
  const userTeam = getUserTeam(event, userId);
  if (!userTeam) return 'not_registered';
  
  const teamIndex = event.registrations.indexOf(userTeam);
  return teamIndex < event.maxTeams ? 'joined' : 'waitlisted';
}

/**
 * Get waitlist position for a team (1-indexed, or null if not waitlisted).
 */
export function getWaitlistPosition(event: Event, teamId: string): number | null {
  const teamIndex = event.registrations.findIndex(team => team.id === teamId);
  if (teamIndex === -1 || teamIndex < event.maxTeams) {
    return null; // Not found or not waitlisted
  }
  return teamIndex - event.maxTeams + 1; // 1-indexed position
}